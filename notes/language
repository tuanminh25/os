Q: C vs C++ 

Well C++ has more feature than C like exception, RTTI, standard lib and those thing are not 
by default handle by a blank kernel 

Linking and runtime set up is more complex

If plan to use C++ but code like C then just use C in the first place, dont even care about C++, it just have extra things to be worried about

More about those "runtime" feature in C++

Those runtime features (exceptions, global constructor, dynamic memory) were written based on principle that it assumes there is an underlying os layer that helps with managing memory, stack, initialization. We are literally at the bare metal creating env. So unless we write own logic to do so, there is no way those stuff would work

Q: Why Rust is rising in kernel dev? 

Because 

- its tooling gets better and their underlying implementation.

- boorrow checker and ownership model prevent many memory bugs (use-after-free, double-free, buffer overflows) at compile time.

- they have more high level features without forcing runtime dependency or relying on os runtime

Q: C++ being used to write driver, why? 

- drivers usually run inside an already-existing kernel (like Linux)

- kernel already implemented

    + stack and heap management

    + memory allocation routines

    + interrupt handling

- which means that runtime-features (manual memory management, some c++ abstraction) can be supported safely on top of kernel services

Q: behind just a same compile command like gcc something in macos, linux, window, there the inner logic is somewhat complicated, huge and dedicated for each of the os?

A: yes

- Compiler front end might be the same or os dependent, like parsing in `gcc main.cpp -o main`

- But for each os, each of function is implemented very differently (new/delete, std::vector, printf, etc) and this is handled by language provider

    +  Linux â†’ uses brk/mmap, glibc

    + Windows â†’ uses HeapAlloc, Windows runtime libraries

    + macOS â†’ uses vm_allocate, libc++

Same C++ code may link to different library code on each os

Q: so when I install c++ on mac, win, linux, each of the os will have its own c++ version being downloaded?

A: 
When you install C++ (e.g., GCC or Clang) on macOS, Windows, or Linux, each OS provides:

Compiler/toolchain binaries

macOS â†’ typically Clang/LLVM (Xcode command line tools)

Linux â†’ GCC or Clang via package manager

Windows â†’ MinGW, MSVC, or Clang

C++ standard library implementation

macOS â†’ libc++

Linux â†’ libstdc++ (GCC) or libc++ (Clang)

Windows â†’ MSVC STL or libstdc++ (MinGW)

ðŸ’¡ So installing C++ on different OSes is not just the compiler, itâ€™s a compiler + OS-tailored standard library combo. Theyâ€™re bundled together because the compiler alone isnâ€™t enoughâ€”the standard library is what actually makes C++ features work on that OS.

Also, Java is a runtime needed language, not directly to hardware. Surprisingly, GO just needs a bit runtime but it can still directly interact barebone hardware


Q: what is the beneficial of runtime language? I think they exist for specific purpose right? For now I can only feel the mainthing is that their syntax is much more simpler, and the requirement for compile is much simpler as well. Is it for the main purpose that they want to abstract out the memory mangament part that other direct to hardware language have?

A: Runtime languages were designed for productivity, safety, and portability, not raw speed or hardware control.

The main purpose is to abstract memory management and low-level details, allowing developers to focus on logic, features, and rapid development, while the runtime handles hardware/OS specifics.

Q and A: if I want to write driver in C++ (assuming to use some runtime features) then my os must be mature enough to handle memory management for runtime support and also I have to figureout a way to map those os feature with C++ run time features

